using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Catapult_ShootCharacter : MonoBehaviour
{
    GameObject catapult;
    GameObject destination;

    public float SHOOTING_ANGLE = 45.0f;
    public float GRAVITY = 9.8f;

    float targetDistance;
    float projectileSpeed;
    Vector2 delta;
    float flightDuration;
    float elapseTime;

    Quaternion originalRotation;
    Vector3 exactDestinationPoint;
    Coroutine projectileSimulationCoroutine;

    bool isCharacterProjectileStarted = false;
    bool isCharacterProjectileProcessing = false;

    [HideInInspector] public bool isOccupied;
    [HideInInspector] public Character capturedCharacter;
    [HideInInspector] public bool isButtonPressed;

    // Use this for initialization
    void Start ()
    {
        catapult = transform.GetChild(0).gameObject;
        destination = transform.GetChild(1).gameObject;

        isOccupied = false;
        isButtonPressed = false;

        projectileSimulationCoroutine = null;
    }
	
	// Update is called once per frame
	void Update ()
    {
        if (!isOccupied && capturedCharacter)
        {
            isOccupied = true;

            if(!capturedCharacter.isDivisible)
            {
                capturedCharacter.isCaptured = true;
                capturedCharacter.transform.position = new Vector3(catapult.transform.position.x,
                                                                    capturedCharacter.transform.position.y,
                                                                    catapult.transform.position.z);
                exactDestinationPoint = new Vector3(destination.transform.position.x,
                                                     capturedCharacter.transform.position.y,
                                                     destination.transform.position.z);
                originalRotation = capturedCharacter.transform.rotation;
            }            
        }

        if (isOccupied && isButtonPressed && !isCharacterProjectileStarted)
        {
            if (!capturedCharacter.isDivisible)
            {
                isCharacterProjectileStarted = true;
                capturedCharacter.rb.useGravity = false;
                capturedCharacter.characterCollision.enabled = false;
            }
        }

        if (isCharacterProjectileStarted && !isCharacterProjectileProcessing)
        {
            isCharacterProjectileProcessing = true;

            if (projectileSimulationCoroutine != null)
                StopCoroutine(projectileSimulationCoroutine);
            projectileSimulationCoroutine = StartCoroutine(SimulateProjectile());      
        }
    }

    IEnumerator SimulateProjectile()
    {
        /* Calculate distance to target */
        targetDistance = Vector3.Distance(capturedCharacter.transform.position, exactDestinationPoint);

        /* Calculate the speed needed to projectile the object to the target at specified angle */
        projectileSpeed = targetDistance / (Mathf.Sin(2 * SHOOTING_ANGLE * Mathf.Deg2Rad) / GRAVITY);

        /* Extract the delta x, y componenent of the velocity */
        delta.x = Mathf.Sqrt(projectileSpeed) * Mathf.Cos(SHOOTING_ANGLE * Mathf.Deg2Rad);
        delta.y = Mathf.Sqrt(projectileSpeed) * Mathf.Sin(SHOOTING_ANGLE * Mathf.Deg2Rad);

        /* Calculate flight time */
        flightDuration = targetDistance / delta.x;

        /* Rotate projectile to face the destination */
        capturedCharacter.transform.rotation = Quaternion.LookRotation(exactDestinationPoint - capturedCharacter.transform.position);

        elapseTime = 0;

        while (elapseTime < flightDuration)
        {
            capturedCharacter.transform.Translate(0, (delta.y - (GRAVITY * elapseTime)) * Time.deltaTime, delta.x * Time.deltaTime);

            elapseTime += Time.deltaTime;

            yield return null;
        }

        capturedCharacter.transform.rotation = originalRotation;
        capturedCharacter.isCaptured = false;
        capturedCharacter.rb.useGravity = true;
        capturedCharacter.characterCollision.enabled = true;
        capturedCharacter = null;
        isOccupied = false;
        isCharacterProjectileStarted = false;
        isCharacterProjectileProcessing = false;
    }
}
