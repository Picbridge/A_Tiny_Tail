using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Character : MonoBehaviour {

    /* legacy code (Begin) */
    public float speed = 1.0f;
    [HideInInspector] public bool isCaptured = false;
    [HideInInspector] public bool isDivisible = false;
    Renderer color;
    public Material divisibleMaterial;
    public Material normalMaterial;
    [HideInInspector] public Rigidbody rb;
    [HideInInspector] public Collider characterCollision;
    /* legacy code (End) */

    /* new code (Begin) */
    public bool isLive { get; private set; }
    public int id;
    /* new code (End) */

    // Use this for initialization
    void Start () {
        color = GetComponent<Renderer>();
        rb = GetComponent<Rigidbody>();
        characterCollision = GetComponent<Collider>();
        isDivisible = false;
        color.material = normalMaterial;
    }
	
	// Update is called once per frame
	void Update () {
        if (Input.GetKeyDown(KeyCode.Space)
            && isDivisible && !isCaptured)
        {
            bool result = Proliferation();

            if (result)
            {
                color.material = normalMaterial;
                isDivisible = false;
            }
        }

        Move();
    }

    void Move()
    {
        if (isCaptured)
            return;

        if (Input.GetKey(KeyCode.W))
                transform.Translate(0.0f, 0.0f, speed * Time.deltaTime);
        if (Input.GetKey(KeyCode.A))
            transform.Translate(-speed * Time.deltaTime, 0.0f, 0.0f);
        if (Input.GetKey(KeyCode.S))
            transform.Translate(0.0f, 0.0f, -speed * Time.deltaTime);
        if (Input.GetKey(KeyCode.D))
            transform.Translate(speed * Time.deltaTime, 0.0f, 0.0f);
    }

    private void OnTriggerEnter(Collider other)
    {
        if(other.tag == "Potion" && !isDivisible)
        {
            isDivisible = true;
            color.material = divisibleMaterial;
            Destroy(other.gameObject);
        }
    }

    private void OnCollisionEnter(Collision collision)
    {        
        if (collision.collider.tag == "Hole")
        {
            Destroy(this);
        }
    }

    //Proliferation : 자가증식하다
    private bool Proliferation()
    {
        Vector3 charaterPos = transform.position;
        Vector3 roundedPos = new Vector3(Mathf.Round(charaterPos.x), Mathf.Round(charaterPos.y), Mathf.Round(charaterPos.z));

        Vector2 characterGrid = new Vector2(roundedPos.x, -roundedPos.z);
        Vector3 goalPos = new Vector3(0, 0, 0);

        float tilePortion = TileMapManager.instance.tilePortion;
        int howManyChecked = 0;

        Tile characterCell = TileMapManager.instance.level[GameSceneIndexManager.instance.currentLevelIndex].tile_map[(int)characterGrid.x, (int)characterGrid.y];

        if (characterCell.isGoingLeft)
        {
            goalPos = new Vector3(roundedPos.x, roundedPos.y, roundedPos.z + tilePortion);
            howManyChecked = 1;
        }
        else if (characterCell.isGoingUp)
        {
            goalPos = new Vector3(roundedPos.x + tilePortion, roundedPos.y, roundedPos.z);
            howManyChecked = 2;
        }
        else if (characterCell.isGoingRight)
        {
            goalPos = new Vector3(roundedPos.x, roundedPos.y, roundedPos.z - tilePortion);
            howManyChecked = 3;
        }
        else if (characterCell.isGoingDown)
        {
            goalPos = new Vector3(roundedPos.x - tilePortion, roundedPos.y, roundedPos.z);
            howManyChecked = 4;
        }
        else
        {
            Debug.Log("CANNOT SEPERATE: Player is surrounding with something");
            return false;
        }

        GameSceneManager gamesceneManger = GameObject.FindObjectOfType<GameSceneManager>();

        if (gamesceneManger.CharacterCheck(goalPos) == false)
        {
            if (characterCell.isGoingUp && howManyChecked < 2)
            {
                goalPos = new Vector3(roundedPos.x + tilePortion, roundedPos.y, roundedPos.z);
            }
            else if (characterCell.isGoingRight && howManyChecked < 3)
            {
                goalPos = new Vector3(roundedPos.x, roundedPos.y, roundedPos.z - tilePortion);
            }
            else if (characterCell.isGoingDown && howManyChecked < 4)
            {
                goalPos = new Vector3(roundedPos.x - tilePortion, roundedPos.y, roundedPos.z);
            }
            else
            {
                Debug.Log("CANNOT SEPERATE_2: Player is surrounding with something");
                return false;
            }
        }

        Character clone = Instantiate(this, goalPos, Quaternion.identity) as Character;
        clone.transform.rotation = transform.rotation;
        clone.transform.SetParent(transform.parent);
        return true;
    }
}
